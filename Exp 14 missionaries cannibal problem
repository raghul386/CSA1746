from collections import deque
def valid(m,c): return (m==0 or m>=c) and (3-m==0 or 3-m>=3-c)
def solve():
    start, goal = (3,3,1), (0,0,0)   # (M_left, C_left, boat_side)
    q, vis = deque([(start,[])]), {start}
    moves=[(1,0),(2,0),(0,1),(0,2),(1,1)]
    while q:
        (m,c,b), path = q.popleft()
        if (m,c,b)==goal:
            print("Solution:", path+[(m,c,b)]); return
        for dm,dc in moves:
            new=(m-dm,c-dc,0) if b else (m+dm,c+dc,1)
            if 0<=new[0]<=3 and 0<=new[1]<=3 and valid(*new[:2]) and new not in vis:
                vis.add(new); q.append((new,path+[(m,c,b)]))
solve()
